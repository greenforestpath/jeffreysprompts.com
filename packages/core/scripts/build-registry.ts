#!/usr/bin/env bun
// packages/core/scripts/build-registry.ts
// Compiles markdown prompts to TypeScript registry

import { readdir, readFile, writeFile } from "node:fs/promises";
import { join, basename } from "node:path";
import matter from "gray-matter";
import { validatePrompt, safeValidatePrompt } from "../src/prompts/schema";

const CONTENT_DIR = join(import.meta.dir, "../src/prompts/content");
const OUTPUT_FILE = join(import.meta.dir, "../src/prompts/registry.generated.ts");

interface BuildResult {
  success: boolean;
  prompts: number;
  errors: string[];
}

async function buildRegistry(): Promise<BuildResult> {
  const errors: string[] = [];
  const prompts: unknown[] = [];

  // Read all markdown files
  const files = await readdir(CONTENT_DIR);
  const mdFiles = files.filter((f) => f.endsWith(".md"));

  console.log(`ðŸ“‚ Found ${mdFiles.length} markdown files in content/`);

  for (const file of mdFiles) {
    const filePath = join(CONTENT_DIR, file);
    const raw = await readFile(filePath, "utf-8");

    // Parse frontmatter
    const { data: frontmatter, content } = matter(raw);

    // Combine frontmatter with content
    const prompt = {
      ...frontmatter,
      content: content.trim(),
    };

    // Validate
    const result = safeValidatePrompt(prompt);

    if (!result.success) {
      errors.push(`âŒ ${file}:\n   ${result.errors.join("\n   ")}`);
      continue;
    }

    prompts.push(result.data);
    console.log(`âœ“ ${file} (${result.data.id})`);
  }

  if (errors.length > 0) {
    console.log("\nâš ï¸  Validation errors:");
    errors.forEach((e) => console.log(e));
  }

  if (prompts.length === 0) {
    return { success: false, prompts: 0, errors: ["No valid prompts found"] };
  }

  // Sort prompts: featured first, then alphabetically by title
  prompts.sort((a: any, b: any) => {
    if (a.featured && !b.featured) return -1;
    if (!a.featured && b.featured) return 1;
    return a.title.localeCompare(b.title);
  });

  // Generate TypeScript
  const ts = generateTypeScript(prompts);
  await writeFile(OUTPUT_FILE, ts);

  console.log(`\nâœ… Generated ${OUTPUT_FILE}`);
  console.log(`   ${prompts.length} prompts compiled`);

  return {
    success: errors.length === 0,
    prompts: prompts.length,
    errors,
  };
}

function generateTypeScript(prompts: unknown[]): string {
  const promptsJson = JSON.stringify(prompts, null, 2);

  // Convert JSON to valid TypeScript (unquote keys, handle special chars)
  const promptsTs = promptsJson
    .replace(/"(\w+)":/g, "$1:") // unquote simple keys
    .replace(/\\n/g, "\\n"); // preserve newlines in strings

  return `// AUTO-GENERATED - DO NOT EDIT
// Generated by: bun run build:prompts
// Source: src/prompts/content/*.md

import type { Prompt } from "./types";

export const prompts: Prompt[] = ${promptsTs};

// Index by ID for fast lookup
export const promptsById = new Map<string, Prompt>(
  prompts.map((p) => [p.id, p])
);

// Get prompt by ID
export function getPrompt(id: string): Prompt | undefined {
  return promptsById.get(id);
}

// Get all prompt IDs
export function getPromptIds(): string[] {
  return prompts.map((p) => p.id);
}
`;
}

// Run
const result = await buildRegistry();
process.exit(result.success ? 0 : 1);
